- JVM运行时内存区域划分

- 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决

- 如何判断对象是否可以回收或存活

- 常见的GC回收算法及其含义

- 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等

- JVM如何设置参数

- JVM性能调优

- 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的

- 类加载的过程：加载、验证、准备、解析、初始化

- 强引用、软引用、弱引用、虚引用

- Java内存模型JMM

- 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 

  *不会，在下一个垃圾回收周期中，这个对象将是可被回收的。* 

- 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 

  吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 

- 在Java中，对象什么时候可以被垃圾回收？ 

  *当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。* 

- JVM的永久代中会发生垃圾回收么？ 

  *垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)* 

- 什么是分布式垃圾回收(DGC)？它是如何工作的？ 

  *DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。* 

- 什么是Java中的内存泄露

  *不再会被使用的对象的内存不能被回收，就是内存泄露。*

  - 如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露 

    `Object obj ;` 

    `public void test(){`

    `obj = new Object();`

    `//其他代码`

    `}`

  - 容器使用发生的内存泄露

    `void test1(){`
            `Vector vector = new Vector();`
    ```        for (int i = 1; i<100; i++){`
    ```            Object object = new Object();`
    ``            `vector.add(object);`
    ```            object = null;`
    ```        }`
            `//...对vector的操作`
           `//...与vector无关的其他操作`
    ``    `}`````

    