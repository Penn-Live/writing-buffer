- JVM运行时内存区域划分

  - *方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；*
  - *堆内存（线程共享）：垃圾回收的主要场所；*
  - *程序计数器： 当前线程执行的字节码的位置指示器；*
  - *虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；*
  - *本地方法栈 ：为 JVM 提供使用 native 方法的服务。*

- 内存溢出OOM和堆栈溢出SOE的示例及原因、如何排查与解决

- 如何判断对象是否可以回收或存活

- 垃圾回收算法有哪些？ 

  1. *引用计数 ：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题；*
  2. *标记-清除 ：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除；*

  *此算法需要暂停整个应用，同时，会产生内存碎片；*

  3. 复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中；*

  *此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间；*

  4. 标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩” 到堆的其中一块，按顺序排放。*

  *此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。*

- 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等

- JVM如何设置参数

- JVM性能调优

- 类加载器、双亲委派模型、一个类的生命周期、类是如何加载到JVM中的

- 类加载的过程：加载、验证、准备、解析、初始化

- 强引用、软引用、弱引用、虚引用

- Java内存模型JMM

- 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 

  *不会，在下一个垃圾回收周期中，这个对象将是可被回收的。* 

- 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 

  吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。 

- 在Java中，对象什么时候可以被垃圾回收？ 

  *当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。* 

- JVM的永久代中会发生垃圾回收么？ 

  *垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)* 

- 什么是分布式垃圾回收(DGC)？它是如何工作的？ 

  *DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。* 

- 什么是Java中的内存泄露

  *不再会被使用的对象的内存不能被回收，就是内存泄露。*

  - 如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露 

    `Object obj ;` 

    `public void test(){`

    `obj = new Object();`

    `//其他代码`

    `}`

  - 容器使用发生的内存泄露

    `void test1(){`
            `Vector vector = new Vector();`
    ```        for (int i = 1; i<100; i++){`
    ```            Object object = new Object();`
    ``            `vector.add(object);`
    ```            object = null;`
    ```        }`
            `//...对vector的操作`
           `//...与vector无关的其他操作`
    ``    `}`````

  - root 搜索算法中，哪些可以作为 root？ 

    - *被启动类（bootstrap 加载器）加载的类和创建的对象；*
    - *JavaStack 中的引用的对象 (栈内存中引用的对象)；*
    - *方法区中静态引用指向的对象；*
    - *方法区中常量引用指向的对象；*
    - *Native 方法中 JNI 引用的对象。*

  - GC 什么时候开始？ 

    *GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。*

    1. *对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；*
    2. *Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。*

    *大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个；XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；*

    1. *发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor GC，如果不允许，则改为进行一次 Full GC。*

  - 内存泄漏和内存溢出

    1. *内存溢出指的是内存不够用了；*
    2. *内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；*
    3. *内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。*

    *内存泄漏的原因分析：*

    1. *长生命周期的对象引用短生命周期的对象；*
    2. *没有将无用对象置为 null。*

  - CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。

  - 标记清除和标记整理算法的理解以及优缺点。

  - eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。

