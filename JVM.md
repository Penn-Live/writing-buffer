- JVM运行时内存区域划分

  - *方法区（线程共享）：常量、静态变量、JIT(即时编译器) 编译后的代码也都在方法区；*
  - *堆内存（线程共享）：垃圾回收的主要场所；*
  - *程序计数器： 当前线程执行的字节码的位置指示器；*
  - *虚拟机栈（栈内存）：保存局部变量、基本数据类型变量以及堆内存中某个对象的引用变量；*
  - *本地方法栈 ：为 JVM 提供使用 native 方法的服务。*

- 垃圾回收算法有哪些？ 

  1. *引用计数 ：原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题；*
  2. *标记-清除 ：此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除；*

  *此算法需要暂停整个应用，同时，会产生内存碎片；*

  3. 复制算法 ：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中；*

  *此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现 “碎片” 问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间；*

  4. 标记-整理 ：此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象 “压缩” 到堆的其中一块，按顺序排放。*

  *此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。*

- 常见的JVM性能监控和故障处理工具类：jps、jstat、jmap、jinfo、jconsole等

- 类加载器、双亲委派模型

     *类加载器分为启动类加载器，用于加载JavaHome下lib下的类，扩展类加载器，用于加载JavaHome下的ext的类加载器，应用程序类加载器，用于加载用户类路径下ClassPath下的指定类库。*

  *双亲委派模型是只从上到下，类加载器的顺序是：启动类加载器，扩展类加载器，应用程序加载器，用户自定义加载器，这几种类加载器通过组合来确定父子关系，工作模式是：当一个类加载器收到类加载的请求的时候，首先自己不去加载这个类，而是请求自己的父加载器去加载，当所有的父加载器都返回无法找到这个类的时候，则自己尝试去加载，如果自己去加载，还是没找到，报ClassNotFund异常。*

- 类加载的过程

  *.类加载的五个阶段：加载，链接(验证，准备，解析)，初始化，使用，卸载。*

     *类执行**初始化**的时机：*

  ​             *主动引用：1）当虚拟机执行以下指令: new,getstatic(访问静态),putstatic（设置静态）,invokevirture（调用静态方法）.*

  ​                             *2）使用java.lang.reflect包的方法对类进行反射的时候。*

  ​                             3）当初始化一个类的时候，发现其父类没有初始化，则会对其父类进行初始化。

  ​                              4）虚拟机启动的时候，需要执行的主类的时候，虚拟机会先初始化这个类。

  ​                              5)使用java.lang.invoke.MethodHandle方法时候，操作static方法的句柄时。

  ​            *别动引用：1）使用子类访问父类的静态属性，父类初始化，子类不会初始化。*

  ​                            2）数组类型，数组的组件类型不会进行初始化。

  ​                            *3）引用别的类的**静态常量，**会执行编译优化，把那个变量编译到本类中，不会导致被引用的类的初始化。*

    *当一个类在初始化的时候，并不要求其接口都已经初始化，只有当用到了父接口的时候（接口中的常量）时候，才会让父接口执行初始化。*

  | 阶段            | 执行过程                                                     |
  | --------------- | ------------------------------------------------------------ |
  | 加载阶段        | *1.通过一个类的全限定类名来获取定义此类的二进制字节流2.将这个类代表的静态存储结构转换为方法区运行时的数据结构。3.在内存中生成一个代表java.lang.Class的对象，作为方法区这个类的各种数据的访问路口* |
  | 连接阶段：验证  | *1.文件格式验证(魔数，常量池中的常量是否符合规范等等)2.元数据验证（继承的类是否规范，类中是否有没有实现的方法等等）3.字节码验证（是否有不被支持的字节，类型转换等等）4.符号引用验证（引用的符号是否存在，权限是否合法等等（编译阶段有优化））* |
  | 连接阶段： 准备 | 正式为类变量分配内存，并且设置“0”值，static final变量赋为常量值 |
  | 连接阶段： 解析 | *将常量池类的**符号引用**替换为**直接引用***                 |
  | 初始化          | *执行<clinit>方法过程    <clinit>：按照源文件中出现的顺序，编译器之地用收集所有的类变量的赋值动作和静态语句块合并产生的。（杜绝非法向前引用）* |

- 强引用、软引用、弱引用、虚引用

- Java内存模型JMM

- 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 

  *不会，在下一个垃圾回收周期中，这个对象将是可被回收的。* 

- 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 

  *吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。* 

- 在Java中，对象什么时候可以被垃圾回收？ 

  [对象的回收过程，待定]

- JVM的永久代中会发生垃圾回收么？ 

  *垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)* 

- 什么是分布式垃圾回收(DGC)？它是如何工作的？ 

  *DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。* 

- 什么是Java中的内存泄露

  *不再会被使用的对象的内存不能被回收，就是内存泄露。*

  - 如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露 

    `Object obj ;` 

    `public void test(){`

    `obj = new Object();`

    `//其他代码`

    `}`

  - 容器使用发生的内存泄露

    `void test1(){`
            `Vector vector = new Vector();`
    ```        for (int i = 1; i<100; i++){`
    ```            Object object = new Object();`
    ``            `vector.add(object);`
    ```            object = null;`
    ```        }`
            `//...对vector的操作`
           `//...与vector无关的其他操作`
    ``    `}`````

  - root 搜索算法中，哪些可以作为 root？ 

    - *被启动类（bootstrap 加载器）加载的类和创建的对象；*
    - *JavaStack 中的引用的对象 (栈内存中引用的对象)；*
    - *方法区中静态引用指向的对象；*
    - *方法区中常量引用指向的对象；*
    - *Native 方法中 JNI 引用的对象。*

  - GC 什么时候开始？ 

    *GC 经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个 Eden 区和两个 Survivor 区。*

    1. *对象优先在 Eden 中分配，当 Eden 中没有足够空间时，虚拟机将发生一次 Minor GC，因为 Java 大多数对象都是朝生夕灭，所以 Minor GC 非常频繁，而且速度也很快；*
    2. *Full GC，发生在老年代的 GC，当老年代没有足够的空间时即发生 Full GC，发生 Full GC 一般都会有一次 Minor GC。*

    *大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个；XX:PretenureSizeThreadhold 参数，令大于这个参数值的对象直接在老年代中分配，避免在 Eden 区和两个 Survivor 区发生大量的内存拷贝；*

    1. *发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次 Full GC，如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor GC，如果不允许，则改为进行一次 Full GC。*

  - 内存泄漏和内存溢出

    1. *内存溢出指的是内存不够用了；*
    2. *内存泄漏是指对象可达，但是没用了。即本该被 GC 回收的对象并没有被回收；*
    3. *内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。*

    *内存泄漏的原因分析：*

    1. *长生命周期的对象引用短生命周期的对象；*
    2. *没有将无用对象置为 null。*

  - CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。

  - eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。

- JVM（堆中对象的分配）：　

　　　　*Java调用`new object()`会创建一个对象，这个对象会被分配到JVM的堆中。那么这个对象到底是怎么在堆中保存的呢？*

​            *首先，`new object()`执行的时候，这个对象需要多大的空间，其实是已经确定的，因为java中的各种数据类型，占用多大的空间都是固定的（对其原理不清楚的请自行Google）。那么接下来的工作就是在堆中找出那么一块空间用于存放这个对象。* 

　　　　*在单线程的情况下，一般有两种分配策略：*

1. *指针碰撞：这种一般适用于内存是绝对规整的（内存是否规整取决于内存回收策略），分配空间的工作只是将指针像空闲内存一侧移动对象大小的距离即可。*

　　　　　　2. *空闲列表：这种适用于内存非规整的情况，这种情况下JVM会维护一个内存列表，记录哪些内存区域是空闲的，大小是多少。给对象分配空间的时候去空闲列表里查询到合适的区域然后进行分配即可。*

　　　　*但是JVM不可能一直在单线程状态下运行，那样效率太差了。由于再给一个对象分配内存的时候不是原子性的操作，至少需要以下几步：查找空闲列表、分配内存、修改空闲列表等等，这是不安全的。解决并发时的安全问题也有两种策略：*

1. *CAS：实际上虚拟机采用CAS配合上失败重试的方式保证更新操作的原子性，原理和上面讲的一样。*

　　　　　　2. *TLAB：如果使用CAS其实对性能还是会有影响的，所以JVM又提出了一种更高级的优化策略：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区（TLAB），线程内部需要分配内存时直接在TLAB上分配就行，避免了线程冲突。只有当缓冲区的内存用光需要重新分配内存的时候才会进行CAS操作分配更大的内存空间。* 
　　　　　　**虚拟机是否使用TLAB，可以通过`-XX:+/-UseTLAB`参数来进行配置（jdk5及以后的版本默认是启用TLAB的）。*