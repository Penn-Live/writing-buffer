- Redis 有哪些数据类型，可参考《[Redis常见的5种不同的数据类型详解](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483987&idx=1&sn=5c5e4cd5bc73a7e6f84e5d6adfab0935&chksm=e9c5fbe2deb272f4b5b75bd2ac92bb27950452623ec83c0e1add7e30c773160421fab1571680&scene=21#wechat_redirect)》

  *String List Set  Hash  Zset* 

- Redis 内部结构

- Redis 使用场景

    *1.不经常变化的，高频访问的数据应该放在redis中。*

  2. *一些不重要的数据，可以放在缓存中。*

- Redis 持久化机制，可参考《[使用快照和AOF将Redis数据持久化到硬盘中](http://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247483992&idx=1&sn=8f554bc490c4db1a78a30144f873e911&chksm=e9c5fbe9deb272fff47483c241e6d2a7aae99dc8f6fe9fee31f2dd214d0cf81b33d51f7a7dbe&scene=21#wechat_redirect)》

  1. *快照：RDB方式*
  2. *追加文件AOF*

- Redis 集群方案与实现

  1. *主从式*
  2. *分片式*

- Redis 为什么是单线程的？

  *官网解释：因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽，而且单线程很容易实现。* 

- 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级

  1. *缓存雪崩：由于原有缓存失效，新缓存未到期间 ，然后导致在Redis上查询压力转移到了数据库上，而对数据库CPU和内存造成了巨大的压力，严重的会造成数据库宕机。从而形成一系列连锁反应。*

  2. *缓存穿透：用户查询数据，在数据库没有，缓存也没有。这样就导用户查询的时候，在缓存中找不到，然后每次都会去数据库查询一遍，导致缓存命中率很低。解决办法：把空的结果也缓存起来。*

  3. *缓存预热：当系统上线后，提前将相关的缓存数据直接加在到缓存系统，避免缓存命中率很低。*

  4. *缓存更新：*

     *除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：*

     *（1）定时去清理过期的缓存；*

     *（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。*

     *两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。*

  5. *缓存降级：*

     *当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。* 

- Redis常见的回收策略

  - *volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰*
  - *volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰*
  - *volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰*
  - *allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰*
  - *allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰*
  - *no-enviction（驱逐）：禁止驱逐数据*

- 如何使用Redis来实现分布式锁【done】

- Redis的并发竞争问题如何解决【单线程】