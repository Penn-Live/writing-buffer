- Java实现多线程有哪几种方式 ？

  *继承 Thread 类与实现 Runnable 接口，实现Callable接口，使用线程框架*

- Callable和Future的了解 ？

- 线程池的参数有哪些，在线程池创建一个线程的过程 ？

- volitile关键字的作用，原理

- synchronized关键字的用法，优缺点

- Lock接口有哪些实现类，使用场景是什么 

- 可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment） 

- 悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决 

- ABC三个线程如何保证顺序执行 

- 线程的状态都有哪些 

- sleep和wait的区别 

  *sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，*
  *但是监控状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。*
  *wait 是 Object 类的方法，对此对象调用 wait 方法导致本线程放弃对象锁，进入等待此对象的*
  *等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准*
  *备获得对象锁进入运行状态。*

- notify和notifyall的区别 

- ThreadLocal的了解，实现原理 

- #### Java BlockingQueue是什么？

  *Java BlockingQueue是一个并发集合util包的一部分。BlockingQueue队列是一种支持操作，它等待元素变得可用时来检索，同样等待空间可用时来存储元素。*

- #### 什么是CopyOnWriteArrayList，它与ArrayList有何不同？

  CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组*进行一次新的复制来实现的。相比较于ArrayList它的写操作要慢一些，因为它需要实例的快照。* 

  *CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差，但是读操作因为操作的对象和写操作不是同一个对象，读之 间也不需要加锁，读和写之间的同步处理只是在写完后通过一个简单的"="将引用指向新的数组对象上来，这个几乎不需要时间，这样读操作就很快很安全，适合 在多线程里使用，绝对不会发生ConcurrentModificationException  ，因此CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。* 

- 你有线程T1，T2和T3，你将如何确保线程T2运行后T1后，T3运行在T2线程后？ 

  *它可以实现通过加入Thread类的**join**方法。*  

  

- Java中新锁接口相比synchronized有什么好处？要实现一个高性能缓存，它允许多个读，但单一的写，以保持完整性，你将如何实施呢？ 

  *新锁接口提供了分离的两个单独读和写的锁，这样能够使用ConcurrentHashMap等高性能数据结构来实现高性能缓存。* 

- 同步和异步有何异同，在什么情况下分别使用他们？举例说明。

  *如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数*
  *据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。*
  *当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的*
  *返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。*

- 请说出你所知道的线程同步的方法

  *wait():使一个线程处于等待状态，并且释放所持有的对象的 lock。*
  *sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 Interrupt*
  *edException 异常。*
  *notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某*
  *一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。*
  *Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。*

- 线程的基本概念、线程的基本状态以及状态之间的关系

   *线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，*
  *也就是程序本身。*

- 

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  


