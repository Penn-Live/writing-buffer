- Java实现多线程有哪几种方式 ？

  *继承 Thread 类与实现 Runnable 接口，实现Callable接口，使用线程框架*

- Callable和Future的了解 ？

- 线程池的参数有哪些，在线程池创建一个线程的过程 ？

- volitile关键字的作用，原理

- synchronized关键字的用法，优缺点

- Lock接口有哪些实现类，使用场景是什么 

- 可重入锁的用处及实现原理，写时复制的过程，读写锁，分段锁（ConcurrentHashMap中的segment） 

- 悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决 

- ABC三个线程如何保证顺序执行 

- 线程的状态都有哪些 

   1. 新建( new )：新创建了一个线程对象。

   2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。

   3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。

   4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：

   (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。

   (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。

   (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。

   5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。

      ![img](http://uploadfiles.nowcoder.net/images/20151217/149974_1450349079825_4697A22AC611680A692472687DEC1CFD)

- sleep和wait的区别 

  *sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，*
  *但是监控状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。*
  *wait 是 Object 类的方法，对此对象调用 wait 方法导致本线程放弃对象锁，进入等待此对象的*
  *等待锁定池，只有针对此对象发出 notify 方法（或 notifyAll）后本线程才进入对象锁定池准*
  *备获得对象锁进入运行状态。*

- notify和notifyall的区别 

- ThreadLocal的了解，实现原理 

- #### Java BlockingQueue是什么？

  *Java BlockingQueue是一个并发集合util包的一部分。BlockingQueue队列是一种支持操作，它等待元素变得可用时来检索，同样等待空间可用时来存储元素。*

- #### 什么是CopyOnWriteArrayList，它与ArrayList有何不同？

  CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作（add、set等等）都是通过对底层数组*进行一次新的复制来实现的。相比较于ArrayList它的写操作要慢一些，因为它需要实例的快照。* 

  *CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差，但是读操作因为操作的对象和写操作不是同一个对象，读之 间也不需要加锁，读和写之间的同步处理只是在写完后通过一个简单的"="将引用指向新的数组对象上来，这个几乎不需要时间，这样读操作就很快很安全，适合 在多线程里使用，绝对不会发生ConcurrentModificationException  ，因此CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。* 

- 你有线程T1，T2和T3，你将如何确保线程T2运行后T1后，T3运行在T2线程后？ 

  *它可以实现通过加入Thread类的**join**方法。*  

  

- Java中新锁接口相比synchronized有什么好处？要实现一个高性能缓存，它允许多个读，但单一的写，以保持完整性，你将如何实施呢？ 

  *新锁接口提供了分离的两个单独读和写的锁，这样能够使用ConcurrentHashMap等高性能数据结构来实现高性能缓存。* 

- 同步和异步有何异同，在什么情况下分别使用他们？举例说明。

  *如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数*
  *据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。*
  *当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的*
  *返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。*

- 请说出你所知道的线程同步的方法

  *wait():使一个线程处于等待状态，并且释放所持有的对象的 lock。*
  *sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉 Interrupt*
  *edException 异常。*
  *notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某*
  *一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。*
  *Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。*

- 线程的基本概念、线程的基本状态以及状态之间的关系

   *线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，*
     *也就是程序本身。*

- 什么是死锁(deadlock)？ 

   *所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：*

   - *互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。*
   - *不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。*
   - *请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。*
   - *循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。*

- 如何确保N个线程可以访问N个资源同时又不导致死锁？ 

   *使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。* 

- 快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？ 

   一：快速失败（fail—fast）

   ​          *在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。*

   ​          *原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。*

   ​      *注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。*

   ​      *场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。*

   ​    *二：安全失败（fail—safe）*

   ​      *采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。*

   ​      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

   ​      *缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。*

   ​          *场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。*

   -----

   

- Synchronized的底层实现:  1. https://www.cnblogs.com/lanhj/p/4638951.html   2. https://www.cnblogs.com/charlesblc/p/5994162.html

- BlockingQueue，CountDownLatch及Semeaphore的使用场景

- 如果要从LinkedBlockingQueue中取出头部对象，分别哪个方法会返回null、抛错、阻塞

   *take - 阻塞，poll - 返回null，remove - 抛错* 

- `ConcurrentHashMap`的实现原理

   *它是一个对写操作加了锁的`HashMap`，不同的是它做了二次分割，元素被存储在不同的桶里，以见效锁的数据范围，提升性能。*

   *在JDK8中对这种实现又进行了修改，JDK8中的`ConcurrentHashmap`基于CAS和`TreeBin`实现的，不需要对segment或者全局加锁，只需要对单行枷锁（hashCode相同），后边的链表是链表加红黑树。对于单个值的修改使用CAS*

- HashMap 的长度为什么是 2 的幂次方？ 

   1. *通过将 Key 的 hash 值与 length-1 进行 & 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；*
   2. *如果 length 为 2 的次幂 则 length-1 转化为二进制必定是 11111……的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；*
   3. *如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大。*

- synchronized 关键字 

   *底层实现：*

   1. *进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；*
   2. *当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。*

   *Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。*

   *该关键字是一个几种锁的封装。*

- volatile 关键字

   *该关键字可以保证可见性不保证原子性。*

   *功能：*

   1. *主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；*
   2. *禁止 JVM 进行的指令重排序。*

- ThreadLocal（线程局部变量）关键字 

   *当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。*

   *ThreadLocal 内部实现机制：*

   1. *每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；*
   2. *Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；*
   3. *Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。*

   ![img](https://images2017.cnblogs.com/blog/1246845/201712/1246845-20171226085834978-974497606.jpg)

- CAS？CAS 有什么缺陷，如何解决？ 

- synchronized 和 lock 有什么区别？ 

-  concurrenthashmap为何读不用加锁 

-  线程池从启动到工作的流程 

   - *刚创建时，里面没有线程*
   - *调用 execute() 添加任务时：*
   - *1）如果正在运行的线程数量小于核心参数corePoolSize，继续创建线程运行这个任务*
   - *2）否则，如果正在运行的线程数量大于或等于corePoolSize，将任务加入到阻塞队列中*
   - *3）否则，如果队列已满，同时正在运行的线程数量小于核心参数maximumPoolSize，继续创建线程运行这个任务*
   - *4）否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize，根据设置的拒绝策略处理*
   - *5）完成一个任务，继续取下一个任务处理*
   - *6）没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束*
   - *7）否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为corePoolSize*

- 如何从FutureTask不阻塞获取结果 

   - *get(long timeout,TimeUnit unit)，超时则返回*
   - *轮询，先通过isDone()判断是否结束，然后调用get()*

- 

































